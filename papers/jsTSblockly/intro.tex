\section{Introduction}

% set up the context and constraints
% we are looking at an easy on-ramp to coding on the web for complete beginners
% leverage JavaScript and TypeScript

Introducing programming to beginners used to be a process fraught with
accidental complexity, due to the need to install tool chains and IDEs, 
typically created with the experienced developer in mind. Today, 
the web has made available a plethora of programming environments;
most any programming language can be experienced via the web. 
Some popular examples include:
\begin{itemize}
\item {\bf JavaScript}: \url{https://jsfiddle.net/};
\item {\bf Python}: \url{https://www.learnpython.org};
\item {\bf Ruby}: \url{http://tryruby.org}.
\end{itemize}
Not surprisingly, all the above approaches still use text editors for coding;
this means that the possibility for introducing errors is still great, especially 
for beginners who don't understand the language. Features such as step-by-step 
tutorials, auto-fixing, and intellisense can
improve the experience, but the starting point still is not the most welcoming. 

% going larger

The ``Hour of Code'' experience,\footnote{\url{https://hourofcode.com/learn}} 
has introduced over half a billion people to coding, with the express purpose 
of demystifying and breaking stereotypes about coding.
In order to reach this many people, \url{code.org} used
Google's Blockly~\cite{Blocky2015}~\footnote{\url{www.github.com/google/blockly}},
a JavaScript framework inspired by MIT's Scratch programming 
environment~\cite{ScratchCACM2009},
to provide a very simple beginning programming experience, 
free of the possibility of syntax errors. 

\begin{figure}[t]
    \includegraphics[width=\columnwidth]{pics/hourofcode}
\caption{\label{fig:hoc}Hour of Code example.}
\end{figure}

Figure~\ref{fig:hoc} shows a screen snapshot from one of the many 
``Hour of Code'' tutorials, in the family of ``maze solving'' problems.

Two goals: 
\begin{itemize}
    \item education about coding; 
    \item education about domains/APIs;
\end{itemize}

% https://www.khanacademy.org/computing/computer-programming/programming/drawing-basics/p/making-drawings-with-code
% http://tryruby.org/levels/1/challenges/0

[goal: bring simplicity of blocky to more domains, to leverage all the JavaSript]

Visual blocks represent structured control-flow statements such as while loops 
and if-then-else conditionals, as well as program expressions, values and variables. 
Blocks also represent function calls to domain-specific APIS, via Blockly's support for \emph{custom 
blocks}. Blockly can be compiled to a variety of languages, the main target 
being JavaScript, as Blockly itself is written in JavaScript and hosted in a web browser.

TypeScript (\url{www.typescriptlang.org}) is superset of the JavaScript language that is gradually typed, 
meaning that types may optionally be added to JavaScript code to provide for a more productive programming 
and debugging experience.  Many JavaScript frameworks provide TypeScript declaration files, as
can be found at the Definitely Typed GitHub repo.~\footnote{\url{https://github.com/DefinitelyTyped/DefinitelyTyped}}.

[need a running example]

The contribution of this paper is to describe a mapping from TypeScript annotated 
JavaScript APIs to Blockly that greatly simplifies 
the process of making existing JavaScript frameworks and libraries available via Blockly.

It is not our goal to map every TypeScript programming construct into Blockly.
For example, a one-to-one mapping of the TypeScript abstract syntax tree (AST) 
nodes to blocks would provide no abstraction, exposing the beginner to a visual 
representation ofTypeScript in its full glory.

Rather, it is support common programming paradigms with a simple mapping
from TypeScript to blocks and back.  This mapping may, in fact, be many-to-one, 
abstracting over multiple TypeScript elements to provide a single block abstraction.
This supports Blockly's goal to provide a simplified programming experience 
with higher-level abstractions. 

The challenge we face is provide a sufficiently rich mapping to handle the
many different API paradigms that JavaScript can support, while
also simplifying the APIs so that they are accessible from Blockly. 

\subsection{Example}

Below is example of a TypeScript function \emph{onButton},
with parameters $b$ and $f$,
that represents a common JavaScript pattern of registering an event
handler ($f$) to be executed when some event occurs (in this case, 
a press of button $A$ or button $B$, as specified in the enumeration
\emph{Button}):
\begin{lstlisting}
enum Button { A, B };
function onButton(b:  Button, 
                  f: () => void): void { }
\end{lstlisting}
The function is explicitly typed using TypeScript's support for
type annotations: each parameter has a type, which follows the colon;
furthermore, the return type of the function also is specified as void
via annotation. 

This function gives rise to a 
block $B$ named ``onButton'', shown in Figure~\ref{fig:onButton}
that represents a \emph{call} to the function
(later sections described how attributes in the comment preceding
the function allow the look and feel of the block to be customized).

The function definition and its types define the block's two \emph{inputs}:
\begin{itemize}
\item  a \emph{value} input corresponding to the parameter
$b$ which allows selection of one of two 
possible parameter values, either ``A'' or ``B'', corresponding to the
the two possible values for the enumeration \emph{Button} ---
while an enumeration is realized as a JavaScript number, a 
Blockly field selector for this parameter only allows
the user to choose either ``A'' or ``B'' (0 or 1);
\item a \emph{statement} input corresponding to the parameter $f$
that allows the user to drag statement blocks inside of block $B$
to define the body of the lambda function passed to $f$.
\end{itemize}
The resulting block allows user to instantiate the function call's
parameter values without the necessity to explicitly create a 
lambda function.  Let $S$ be the sequence of TypeScript statements
corresponding to the blocks of $B$'s statement input and XYZ. 

[TODO: show the block and the resulting TypeScript call]



\subsection{Overview}



% Nonetheless, there are features of the TypeScript language that one usually
% finds lacking in Blockly instantations, such as explicit use of lexical scoping,


% \begin{itemize}
%   \item lexical scoping (via let);
%   \item functions as values (also nested functions -> closures);
%   \item classes with single inheritance, methods, objects
%   \item arrays (lists);
%   \item object destructuring
% \end{itemize}

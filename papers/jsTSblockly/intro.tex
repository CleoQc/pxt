\section{Introduction}

% set up the context and constraints
% we are looking at an easy on-ramp to coding on the web for complete beginners
% leverage JavaScript and TypeScript

Introducing programming to beginners used to be a process fraught with
accidental complexity, due to the need to install tool chains and IDEs, 
typically created with the professional developer in mind. Today, 
the web has made available a plethora of programming environments;
most any programming language can be experienced via the web. 
Some popular examples include:
\begin{itemize}
\item {\bf JavaScript}: \url{https://jsfiddle.net/};
\item {\bf Python}: \url{https://www.learnpython.org};
\item {\bf Ruby}: \url{http://tryruby.org}.
\end{itemize}
Not surprisingly, all the above approaches still use text editors for coding;
this means that the possibility for introducing errors is still great, especially 
for beginners who don't understand the language. Features such as step-by-step 
tutorials and intellisense can improve the experience, but the starting point still 
is not the most welcoming. 

% going larger

The ``Hour of Code'' experience,\footnote{\url{https://hourofcode.com/learn}} 
has introduced over three hundred million students to coding,\footnote{https://code.org/about/2016} 
with the express  purpose of demystifying and breaking stereotypes about coding.
In order to reach this many people, \url{code.org} used
Google's Blockly~\cite{Blocky2015}~\footnote{\url{www.github.com/google/blockly}},
a JavaScript framework inspired by MIT's Scratch programming 
environment~\cite{ScratchCACM2009},
to provide a very simple beginning programming experience, 
free of the possibility of syntax errors. 

\begin{figure}[t]
    \includegraphics[width=\columnwidth]{pics/hourofcode}
\caption{\label{fig:hoc}Hour of Code example.}
\end{figure}

Figure~\ref{fig:hoc} shows a screen snapshot from one of the many 
``Hour of Code'' tutorials, in the family of ``maze solving'' problems.
In this example, the goal is to program the Minecraft avatar ``Steve''
on the left of the tiny 2D world labelled ``MINECRAFT''
to move to the sheep on the right. To create a program,
the user selects from a simple palette of three blocks
(shown under the ``Blocks'' heading) and drags these blocks into
the workspace. In this very simple example, the
program is simply a sequence of commands. In later steps, 
concepts such as loops and conditionals are introduced.

In Blockly, colored blocks represent structured control-flow statements such as loops 
and if-then-else conditionals, as well as program expressions, values and variables. 
Blocks also represent function calls to domain-specific APIS, via Blockly's support 
for \emph{custom blocks}.\footnote{
\url{https://developers.google.com/blockly/guides/create-custom-blocks/overview}}
In the case of Figure~\ref{fig:hoc}, the domain-specific 
APIs are the commands for moving ``Steve''.
Blockly can be compiled to a variety of languages, the main target 
being JavaScript, as Blockly itself is written in JavaScript 
and hosted in a web browser.

As the Blockly documentation states, 
``Blockly is a complicated library targeted at experienced developers'',
using both the JSON format and JavaScript APIs for creating custom blocks
programmatically. 

Our goal is to make it easier to bring the Blockly editing experience to more
domains, leveraging the numerous JavaScript libraries available on the web, but
without needing to become experienced with the Blockly framework.

TypeScript (\url{www.typescriptlang.org}) is superset of the JavaScript language that is gradually typed, 
meaning that types may optionally be added to JavaScript code to provide for a more productive programming 
and debugging experience.  Many JavaScript frameworks provide TypeScript declaration files, as
can be found at the Definitely Typed GitHub repo.
~\footnote{\url{https://github.com/DefinitelyTyped/DefinitelyTyped}}
Our contribution is to describe a mapping from TypeScript annotated 
JavaScript APIs to Blockly that greatly simplifies 
the process of making JavaScript code available via Blockly.

It is not our goal to map every TypeScript programming construct into Blockly.
For example, a one-to-one mapping of the TypeScript abstract syntax tree (AST) 
nodes to blocks would provide no abstraction, exposing the beginner to a visual 
representation of TypeScript in its full glory.

Rather, it is support common programming paradigms with a simple mapping
from TypeScript to blocks and back.  This mapping may, in fact, be many-to-one, 
abstracting over multiple TypeScript elements to provide a single block abstraction.
This supports Blockly's goal to provide a simplified programming experience 
with higher-level abstractions. 

The challenge we face is provide a sufficiently rich mapping to handle the
many different API paradigms that JavaScript can support, while
also simplifying the APIs so that they are accessible from Blockly. 

\subsection{Example}

Below is example of a TypeScript function \emph{onButton},
with parameters $b$ and $f$,
that represents a common JavaScript pattern of registering an event
handler ($f$) to be executed when some event occurs (in this case, 
a press of button $A$ or button $B$, as specified in the enumeration
\emph{Button}):
\begin{lstlisting}
enum Button { A, B };
function onButton(b:  Button, 
                  f: () => void): void { }
\end{lstlisting}
The function is explicitly typed using TypeScript's support for
type annotations: each parameter has a type, which follows the colon;
furthermore, the return type of the function also is specified as void
via annotation. 

This function gives rise to a 
block $B$ named ``onButton'', shown in Figure~\ref{fig:onButton}
that represents a \emph{call} to the function
(later sections described how attributes in the comment preceding
the function allow the look and feel of the block to be customized).

The function definition and its types define the block's two \emph{inputs}:
\begin{itemize}
\item  a \emph{value} input corresponding to the parameter
$b$ which allows selection of one of two 
possible parameter values, either ``A'' or ``B'', corresponding to the
the two possible values for the enumeration \emph{Button} ---
while an enumeration is realized as a JavaScript number, a 
Blockly field selector for this parameter only allows
the user to choose either ``A'' or ``B'' (0 or 1);
\item a \emph{statement} input corresponding to the parameter $f$
that allows the user to drag statement blocks inside of block $B$
to define the body of the lambda function passed to $f$.
\end{itemize}
The resulting block allows user to instantiate the function call's
parameter values without the necessity to explicitly create a 
lambda function.  Let $S$ be the sequence of TypeScript statements
corresponding to the blocks of $B$'s statement input and XYZ. 

[TODO: show the block and the resulting TypeScript call]

\subsection{Overview}



% Nonetheless, there are features of the TypeScript language that one usually
% finds lacking in Blockly instantations, such as explicit use of lexical scoping,


% \begin{itemize}
%   \item lexical scoping (via let);
%   \item functions as values (also nested functions -> closures);
%   \item classes with single inheritance, methods, objects
%   \item arrays (lists);
%   \item object destructuring
% \end{itemize}


% https://www.khanacademy.org/computing/computer-programming/programming/drawing-basics/p/making-drawings-with-code
% http://tryruby.org/levels/1/challenges/0

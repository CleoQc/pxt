% blockId is a constant, unique id for the block. This id is serialized in block code so changing it will break your users.
% block contains the syntax to build the block structure (more below).
% Other optional attributes can also be used:

% blockExternalInputs= forces External Inputs rendering
% advanced=true causes this block to be placed under the parent category’s “More…” subcategory. Useful for hiding advanced or rarely-used blocks by default
% Block syntax


\section{Mapping}

\subsection{Primitive Values}

% The following types are supported in function signatures that are meant to be exported:

% boolean
% number (TypeScript)
% string (TypeScript) 

\subsection{API Function Calls}

API represented by
\begin{itemize}
  \item namespaces to organize set of related functions, 
       where namespaces map to Toolbox categories in Blockly;
       In particular, each top-level namespace is used to populate a category 
       in the toolbox. The name of the namespaces is capitalized for the toolbox. 

  \item void return type for a function means a call to the function is allowable in
      a statement context; non-void means expression context for call
  \item functions return a single value;
  \item parameters: optional parameters with default value; rest; 
\end{itemize}

% Block syntax

% The block attribute specifies how the parameters of the function will be organized to create the block.

% block = field, { '|' field }
% field := string
%     | string `%` parameter [ `=` type ]
% parameter = string
% type = string
% each field is mapped to a field in the block editor
% the function parameter are mapped in order to %parameter argument. 

% The loader automatically builds a mapping between the block field names and the function names.
% the block will automatically switch to external inputs when enough parameters are detected
% A block type =type can be specified optionally for each parameter. It will be used to populate the shadow type.
% Supported types

\subsection{Enumerations}

\subsection{Objects and Object Destructuring}
API represented by
\begin{itemize}
  \item set of classes, with
  \item constructors
  \item methods/fields
\end{itemize}

\subsection{Event Handlers and Callbacks}

% \item event-handlers via a callback function (callbacks only have parameters with primitive values);

A function $f$ that has an argument $g$ of function type (in last position) will have
that function argument (callback) converted into a statement input of $B(f)$.

If the callback $g$ has parameters, then
the best way to map that pattern to the blocks is by modifying
$g$ to have a single parameter with a class type that has the
various parameters as fields.
For example:

% export class ArgumentClass {
%     argumentA: number;
%     argumentB: string;
% }

% //% mutate=objectdestructuring
% //% mutateText="My Arguments"
% //% mutateDefaults="argumentA;argumentA,argumentB"
% // ...
% export function addSomeEventHandler((a: ArgumentClass) => void) { };

% In the above example, setting mutate=objectdestructuring will cause this API 
% to use Blockly “mutators” to let users change what parameters appear in the blocks. 
% Each parameter will be given an optional variable field in the block that defines a 
% variable that can be used within the callback. The variable fields compile to object
% destructuring in the TypeScript code. For example:

% addSomeEventHandler(({argumentA, argumentB}) => {

% })

% For an example of this pattern in action, see the radio.onDataPacketReceived block in the microbit target.

% In some cases it can be useful to change the runtime behavior of the API based on the properties 
% selected by the user. To enable that behavior, create an enum with entries that have the same names 
% as the argument object’s properties and add an extra parameter taking in an enum array to the API. 
% For example:

% export class ArgumentClass {
%     argumentA: number;
%     argumentB: string;
% }

% enum ArgNames {
%     argumentA,
%     argumentB
% }

% //% mutate=objectdestructuring
% //% mutateText="My Arguments"
% //% mutateDefaults="argumentA;argumentA,argumentB"
% //% mutatePropertyEnum="argNames"
% // ...
% export function addSomeEventHandler(args: ArgNames[], (a: ArgumentClass) => void) { };
% Note the mutatePropertyEnum attribute added to the comment annotations. The block for this API will look the same as the previous example but the compiled code will also include the arguments passed:

% addSomeEventHandler([ArgNames.argumentA, ArgNames.argumentB], ({argumentA, argumentB}) => {

% })
% The other attributes related to object destructuring mutators include:

% mutateText - defines the text that appears in the top block of the Blockly mutator dialog (the dialog that appears when you click the blue gear)
% mutateDefaults - defines the versions of this block that should appear in the toolbox. Block definitions are separated by semicolons and property names should be separated by commas

\subsection{Lexical Scoping}

% to be implemented
% in most blockly programs, variables are used without being declared
% we use the block structure to determine where to place declaration
% given a set of uses U(X) of variable X, we take the least common ancestor
% of U(X) and place the declaration for X there when translating from
% blockly to typescript

% this means we won't preserve